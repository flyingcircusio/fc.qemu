from .hazmat.qemu import Qemu
import os.path
import yaml
from .timeout import TimeOut


def running(expected=True):
    def wrap(f):
        def checked(self, *args, **kw):
            if self.qemu.is_running() != expected:
                raise RuntimeError('action not allowed')
            return f(self, *args, **kw)
        return checked
    return wrap


class Agent(object):
    """The agent to control a single VM."""

    def __init__(self, name):
        if '.' in name:
            cfg = name
        else:
            cfg = '/etc/qemu/vm/{}.cfg'.format(name)
        if not os.path.isfile(cfg):
            raise RuntimeError("Could not find {}".format(cfg))
        self.cfg = yaml.load(open(cfg))
        self.qemu = Qemu(self.cfg)
        #self.ceph = Ceph()

    def ensure(self):
        self.ensure_online_status()
        self.ensure_online_disk_size()

    @running(False)
    def start(self):
        self.generate_config()
        # self.ceph.start()
        self.qemu.start()

    def status(self):
        """Determine status of the VM.
        """
        return 'running' if self.qemu.is_running() else 'stopped'

    @running(True)
    def stop(self):
        timeout = TimeOut(120, interval=1)
        self.qemu.stop()
        while timeout.tick():
            if not self.qemu.running():
                self.ceph.stop_volumes()
                break
        else:
            self.kill()

    @running(True)
    def kill(self):
        timeout = TimeOut(15, interval=1, raise_on_timeout=True)
        self.qemu.kill()
        while timeout.tick():
            if not self.qemu.running():
                self.ceph.stop_volumes()
                break

    @running(False)
    def create(self):
        pass

    @running(False)
    def delete(self):
        # XXX require a safety belt: make an online check that this
        # VM really should be deleted.
        pass

    @running(False)
    def inmigrate(self):
        pass

    @running(True)
    def outmigrate(self):
        pass

    # Helper methods

    # CAREFUL: changing anything in this config files will cause maintenance w/
    # reboot of all VMs in the infrastructure.
    def generate_config(self):
        """Generate a new Qemu config (and options) for a freshly
        starting VM.

        The configs are intended to be non-host-specific and can use {hostname}
        and {suffix} formatting that will later be filled in when actually
        starting VM.

        This two-step behaviour is needed to support migrating VMs
        and keeping arguments consistent while allowing to localize arguments
        to the host running or receiving the VM.

        """
        self.qemu.args = [
            '-daemonize',
            '-nodefaults',
            '-chroot /srv/vm/{name}',
            '-runas nobody',
            '-serial file:/var/log/vm/{name}.log',
            '-display vnc={{hostname}}.mgm.{{suffix}}:{id}',
            '-vga cirrus',
            '-m {memory}',
            '-watchdog i6300esb',
            '-watchdog-action reset',
            '-readconfig {{configfile}}']
        self.qemu.args = [a.format(**self.cfg) for a in self.qemu.args]

        self.qemu.config = """\
# qemu config file
# generated by localconfig. do not edit.

[machine]
  accel = "kvm"
  type = "pc-q35-2.1"

[smp-opts]
  cpus = "{cores}"

[name]
  guest = "{name}"
  process = "kvm.{name}"

[drive]
  index = "0"
  media = "disk"
  if = "virtio"
  format = "rbd"
  file = "rbd:{resource_group}/{name}.root:id={{hostname}}"
  aio = "native"
  cache = "writeback"

[drive]
  index = "1"
  media = "disk"
  if = "virtio"
  format = "rbd"
  file = "rbd:{resource_group}/{name}.swap:id=${{HOSTNAME}}"
  aio = "native"
  cache = "writeback"

[drive]
  index = "2"
  media = "disk"
  if = "virtio"
  format = "rbd"
  file = "rbd:{resource_group}/{name}.tmp:id=${{HOSTNAME}}"
  aio = "native"
  cache = "writeback"

[device]
  driver = "virtio-rng-pci"

# Guest agent support
[device]
  driver = "virtio-serial"

[device]
  driver = "virtserialport"
  chardev = "qga0"
  name = "org.qemu.guest_agent.0"

[chardev "qga0"]
  backend = "socket"
  path = "/run/kvm.{name}.gqa.sock"
  server = "on"
  wait = "off"

# QMP monitor support via Unix socket

[mon "qmp_monitor"]
  mode = "control"
  chardev = "ch_qmp_monitor"
  default = "on"

[chardev "ch_qmp_monitor"]
  backend = "socket"
  path = "/run/kvm.{name}.qmp.sock"
  server = "on"
  wait = "off"

# Human monitor support via Unix socket

[chardev "ch_readline_socket_monitor"]
  backend = "socket"
  path = "/run/kvm.{name}.monitor.sock"
  server = "on"
  wait = "off"

[mon "readline_socket_monitor"]
  mode = "readline"
  chardev = "ch_readline_socket_monitor"

# Human monitor support via localhost IP

[chardev "ch_readline_telnet_monitor"]
  backend = "socket"
  host = "localhost"
  port = "{monitor_port}"
  server = "on"
  wait = "off"

[mon "readline_telnet_monitor"]
  mode = "readline"
  chardev = "ch_readline_telnet_monitor"

# Network interfaces

"""
        for net, net_config in sorted(self.cfg['interfaces'].items()):
            ifname = 't{}{}'.format(net, self.cfg['id'])
            self.qemu.config += """
[device]
  driver = "virtio-net-pci"
  netdev = "{ifname}"
  mac = "{mac}"

[netdev "{ifname}"]
  type = "tap"
  ifname = "{ifname}"
  script = "/etc/kvm/kvm-ifup"
  downscript = "/etc/kvm/kvm-ifdown"
  vhost = "on"
""".format(ifname=ifname, mac=net_config['mac'])
